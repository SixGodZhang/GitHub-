# 从IL来看待C#的闭包问题

C# 中的闭包其实是一个细节问题，出现这个事故(暂且称之为事故)的根本原因是匿名委托。

先说说匿名委托的机制:
分以下l两种情形来描述编译器是如何处理匿名委托的:
- 匿名委托 内部未使用外部变量(仅介绍，不会造成闭包问题)
- 匿名委托 内部使用了外部变量(因使用方法不当会造成闭包问题)
当编译器(注意是编译器，不是CLR)发现调用的方法中存在匿名委托时,且匿名委托内部未使用外部局部变量,如下图所示:
![匿名委托内部未使用外部局部变量](https://github.com/SixGodZhang/Materials/blob/master/Images/originaldelegateIL.png)

可以看见，匿名委托会被声明为类的私有的静态字段

但是，当使用了外部的局部变量之后，编译器对匿名委托的处理就会如下:
![匿名委托内部未使用外部局部变量](https://github.com/SixGodZhang/Materials/blob/master/Images/2.png)

可以看见,编译器会为匿名委托创建一个私有的内部类,其中在这个内部类中包含了与的外部局部变量同名的公开的字段,还包含一个共有的实例方法
该实例方法包含了对委托内容的实现

闭包问题的触发条件:
从上面的分析，加上对IL代码的理解,拿这个方法简述一下过程:
``` csharp
using System;

internal class Program
{
    private static void Main(string[] args)
    {
        //Main方法调用前期准备工作:
        //CLR 在调用Main方法时,先检测方法内的局部变量
        //变量是一个常量字符串,存储在元数据中，可以直接读取,存在字符串池中
        //之后，Main方法发现有传入局部变量的匿名委托,
        //则在线程栈上进行声明
        //在真正调用Main方法时:
        //先创建一个辅助类,该辅助类中包含匿名委托的实例方法及在匿名委托中引用的局部变量
        //大概就是这个样子
        //private sealed class 辅助类名
        // ｛
        //      public 局部变量类型 局部变量名;
        //      ....
        //      public 匿名委托匹配的实例方法
        //  ｝
        //然后,初始化辅助类(即创建辅助类的一个实例,调用辅助类的构造方法创建)
        //然后将局部变量的值和指向辅助类的匿名委托匹配的实例方法的指针(native int) 放到计算堆栈上
        //再,调用为匿名委托注册该方法
        //最后在需要调用该匿名委托的时候直接进行调用
        string b = "b";//存储在元数据中
        
        DoAction("play", a => { Console.WriteLine(a + b); });
    }

    public static void DoAction(string arg, Action<string> action)
    {
        //Console.WriteLine(arg);
        if (action != null)
            action(arg);
    }
}
```

就此，我们可以知道,在调用方法时，先会为辅助类创建一个实例,并为其中的字段赋值。这个匿名委托如果所有属性(这里指
参数签名，返回值类型)一致的话，编译器仅仅只会创建一个辅助类,且这个辅助类只有一个实例

如果匿名类出现在迭代中,且在匿名委托中使用的是一个对于匿名委托来说的"恒定"的变量，而不是多个临时变量，就会出现闭包.

这里的恒定是一个的意思，就是说匿名委托使用的是一个变量，还是说会使用多个变量.

对于编译器来说,匿名委托接收传进来的变量是一个，还是多个，会影响它的处理判断,
如果是一个，那编译器只会创建一个实例，所以在这一个实例中，纵使迭代多次，影响的只是这个实例中引用的变量,如这个
变量在迭代中叠加,那么当迭代完成时，这个变量就会被改成最终值，当在调用这个委托的实例时，委托处理的就是这个最终值.

如果是多个，编译器则认为这是不同的委托实例，则会创建多个委托实例，每个委托实例对应的都是不同的临时变量的值，便可以解决
问题.
以下IL代码，便可以验证所说:
